import { serve } from "https://deno.land/std@0.208.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

serve(async (req) => {
  const startTime = Date.now();
  const requestId = `req_${startTime}_${Math.random().toString(36).substr(2, 9)}`;
  
  console.log(`üî• [${requestId}] === WEBHOOK RECEIVER INICIADO ===`);
  console.log(`üî• [${requestId}] M√©todo: ${req.method}`);
  console.log(`üî• [${requestId}] URL: ${req.url}`);
  console.log(`üî• [${requestId}] Headers:`, Object.fromEntries(req.headers.entries()));
  
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    console.log(`üî• [${requestId}] CORS preflight - retornando OK`);
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    console.log(`üî• [${requestId}] Lendo body da requisi√ß√£o...`);
    const body = await req.json();
    console.log(`üî• [${requestId}] Body lido com sucesso`);
    
    const { instance, data } = body;

    console.log(`üî• [${requestId}] --- üöÄ Iniciando Webhook Receiver ---`);
    console.log(`üî• [${requestId}] Inst√¢ncia recebida: ${instance}`);
    console.log(`üî• [${requestId}] Dados presentes: ${data ? 'SIM' : 'N√ÉO'}`);
    
    // N√£o logar o body inteiro se contiver base64 (muito grande)
    if (data?.message?.imageMessage?.jpegThumbnail) {
        console.log(`üî• [${requestId}] Payload recebido (imagem com thumbnail).`);
    } else {
        console.log(`üî• [${requestId}] Payload completo:`, JSON.stringify(data, null, 2));
    }

    if (!data || !data.key || !data.key.remoteJid) {
      console.log(`üî• [${requestId}] üîö Webhook sem dados essenciais (remoteJid). Ignorando.`);
      return new Response("ok - ignorado", { headers: corsHeaders });
    }

    const { key, pushName, message, messageTimestamp } = data;
    const fromMe = key.fromMe;
    const remoteJid = key.remoteJid;

    console.log(`üî• [${requestId}] Key extra√≠da:`, key);
    console.log(`üî• [${requestId}] PushName: ${pushName}`);
    console.log(`üî• [${requestId}] FromMe: ${fromMe}`);
    console.log(`üî• [${requestId}] RemoteJid: ${remoteJid}`);
    console.log(`üî• [${requestId}] MessageTimestamp: ${messageTimestamp}`);

    if (remoteJid.includes('@broadcast')) {
      console.log(`üî• [${requestId}] üîö Mensagem de broadcast. Ignorando.`);
      return new Response("ok - broadcast ignorado", { headers: corsHeaders });
    }

    // üêõ CORRE√á√ÉO: Ignorar mensagens enviadas por mim para evitar duplica√ß√£o
    if (fromMe) {
      console.log(`üî• [${requestId}] ‚û°Ô∏è Mensagem enviada por mim (fromMe: true). Ignorando para evitar duplica√ß√£o.`);
      return new Response("ok - mensagem pr√≥pria ignorada", { headers: corsHeaders });
    }

    const clientPhone = remoteJid.split('@')[0];
    const clientName = fromMe ? 'Eu' : (pushName || 'Novo Contato');
    console.log(`üî• [${requestId}] üí¨ Mensagem ${fromMe ? 'de' : 'para'} ${clientName} (${clientPhone})`);

    console.log(`üî• [${requestId}] Criando cliente Supabase...`);
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!, 
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );
    console.log(`üî• [${requestId}] Cliente Supabase criado`);

    console.log(`üî• [${requestId}] ‚öôÔ∏è Buscando usu√°rio para a inst√¢ncia: ${instance}`);

    console.log(`üî• [${requestId}] Executando query na tabela settings...`);
    const { data: settings, error: settingsError } = await supabase
      .from('settings')
      .select('user_id')
      .eq('evolution_instance_name', instance)
      .single();

    console.log(`üî• [${requestId}] Resultado da query settings:`, { settings, settingsError });

    if (settingsError || !settings?.user_id) {
      console.error(`üî• [${requestId}] ‚ùå Erro: Configura√ß√µes ou user_id n√£o encontrados para a inst√¢ncia ${instance}.`, settingsError);
      
      // Tentar buscar por instance_name como fallback
      console.log(`üî• [${requestId}] Tentando fallback com instance_name...`);
      const { data: fallbackSettings, error: fallbackError } = await supabase
        .from('settings')
        .select('user_id')
        .eq('instance_name', instance)
        .single();
        
      console.log(`üî• [${requestId}] Resultado do fallback:`, { fallbackSettings, fallbackError });
        
      if (fallbackError || !fallbackSettings?.user_id) {
        console.error(`üî• [${requestId}] ‚ùå Erro: Configura√ß√µes n√£o encontradas nem como evolution_instance_name nem como instance_name para ${instance}.`);
        return new Response(
          JSON.stringify({ 
            error: `Configura√ß√µes n√£o encontradas para a inst√¢ncia ${instance}`,
            details: settingsError?.message || 'Inst√¢ncia n√£o configurada'
          }), 
          { 
            status: 404, 
            headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
          }
        );
      }
      
      settings.user_id = fallbackSettings.user_id;
      console.log(`üî• [${requestId}] ‚úÖ Usu√°rio encontrado via fallback: ${settings.user_id}`);
    }
    
    const assignedUserId = settings.user_id;
    console.log(`üî• [${requestId}] ‚úÖ Usu√°rio da inst√¢ncia: ${assignedUserId}`);

    console.log(`üîç Buscando cliente pelo telefone: ${clientPhone}`);
    let { data: client } = await supabase
      .from('clients')
      .select('id, name')
      .eq('phone', clientPhone)
      .single();

    if (!client) {
      // S√≥ cria cliente se a mensagem for RECEBIDA de um n√∫mero novo.
      if (!fromMe) {
          // üîß CORRE√á√ÉO: Melhorar l√≥gica de nome do cliente
          const clientName = pushName && pushName.trim() && pushName !== clientPhone 
            ? pushName.trim() 
            : `Contato ${clientPhone}`;
            
          console.log(`ü§î Cliente n√£o encontrado. Criando novo: Nome='${clientName}', Tel='${clientPhone}'`);
          const { data: newClient, error: newClientError } = await supabase
            .from('clients')
            .insert({ 
              name: clientName, 
              phone: clientPhone, 
              status: 'ativo', 
              created_by: assignedUserId 
            })
            .select('id, name')
            .single();
          
          if (newClientError) {
              console.error('‚ùå Erro ao criar novo cliente:', newClientError);
              throw newClientError;
          }
          client = newClient;
          console.log(`‚úÖ Cliente criado com sucesso: ID=${client!.id}`);
      } else {
          console.log('‚û°Ô∏è Mensagem de sa√≠da para n√∫mero n√£o-cliente. N√£o criando cliente.');
          return new Response("ok - mensagem de sa√≠da para n√£o-cliente", { headers: corsHeaders });
      }
    } else {
      console.log(`‚úÖ Cliente existente encontrado: ${client.name} (ID=${client.id})`);
      
      // üéØ OPCIONAL: Atualizar nome apenas se o atual for gen√©rico e o pushName for melhor
      if (pushName && 
          pushName.trim() && 
          pushName !== clientPhone &&
          (client.name.startsWith('Contato ') || client.name === clientPhone)) {
        
        console.log(`üîÑ Atualizando nome gen√©rico "${client.name}" para "${pushName}"`);
        
        const { error: updateError } = await supabase
          .from('clients')
          .update({ name: pushName.trim() })
          .eq('id', client.id);
          
        if (!updateError) {
          client.name = pushName.trim();
          console.log('‚úÖ Nome do cliente atualizado');
        }
      }
    }

    console.log(`üîÑ Buscando conversa para o cliente ID: ${client!.id}`);
    let { data: conversation } = await supabase
      .from('conversations')
      .select('id')
      .eq('client_id', client!.id)
      .single();

    if (!conversation) {
      console.log(`ü§î Conversa n√£o encontrada. Criando nova...`);
      const { data: newConv, error: newConvError } = await supabase
        .from('conversations')
        .insert({ 
          client_id: client!.id, 
          status: 'active', 
          assigned_to: assignedUserId 
        })
        .select('id')
        .single();

      if (newConvError) {
        console.error('‚ùå Erro ao criar nova conversa:', newConvError);
        throw newConvError;
      }
      conversation = newConv;
      console.log(`‚úÖ Nova conversa criada: ID=${conversation!.id}`);
    } else {
      console.log(`‚úÖ Conversa existente encontrada: ID=${conversation.id}`);
    }

    // üéØ Fun√ß√£o para baixar m√≠dia e fazer upload para Supabase Storage
    const downloadAndUploadMedia = async (url: string, fileName: string, mimeType: string, clientId: string) => {
      try {
        console.log(`üì• Baixando m√≠dia de: ${url}`);
        
        // Baixar a m√≠dia da Evolution API
        const response = await fetch(url);
        if (!response.ok) {
          console.error(`‚ùå Erro ao baixar m√≠dia: ${response.status} ${response.statusText}`);
          return null;
        }
        
        const arrayBuffer = await response.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        
        // Gerar nome √∫nico para o arquivo
        const timestamp = Date.now();
        const extension = fileName.split('.').pop() || 'bin';
        const uniqueFileName = `${clientId}/${timestamp}_${fileName}`;
        
        console.log(`üì§ Fazendo upload para Supabase Storage: ${uniqueFileName}`);
        
        // Upload para Supabase Storage
        const { data: uploadData, error: uploadError } = await supabase.storage
          .from('whatsapp-media')
          .upload(uniqueFileName, uint8Array, {
            contentType: mimeType,
            upsert: true
          });
        
        if (uploadError) {
          console.error('‚ùå Erro no upload para Supabase Storage:', uploadError);
          return null;
        }
        
        // Obter URL p√∫blica
        const { data: publicUrlData } = supabase.storage
          .from('whatsapp-media')
          .getPublicUrl(uploadData.path);
        
        console.log(`‚úÖ M√≠dia salva com sucesso: ${publicUrlData.publicUrl}`);
        return {
          publicUrl: publicUrlData.publicUrl,
          fileSize: uint8Array.length
        };
        
      } catch (error) {
        console.error('‚ùå Erro ao processar m√≠dia:', error);
        return null;
      }
    };

    let content = 'M√≠dia recebida';
    let message_type = 'media';
    let media_url = null;
    let media_type = null;
    let file_name = null;
    let file_size = null;

    if (message?.conversation) {
        content = message.conversation;
        message_type = 'text';
    } else if (message?.extendedTextMessage?.text) {
        content = message.extendedTextMessage.text;
        message_type = 'text';
    } else if (message?.imageMessage) {
        content = message.imageMessage.caption || 'Imagem';
        message_type = 'image';
        media_type = message.imageMessage.mimetype || 'image/jpeg';
        file_name = `image_${messageTimestamp}.jpg`;
        
        // üîß CORRE√á√ÉO: Baixar e fazer re-upload da imagem
        if (message.imageMessage.url) {
          const mediaResult = await downloadAndUploadMedia(
            message.imageMessage.url, 
            file_name, 
            media_type, 
            client!.id
          );
          if (mediaResult) {
            media_url = mediaResult.publicUrl;
            file_size = mediaResult.fileSize;
          } else {
            // Fallback para URL original se o download falhar
            media_url = message.imageMessage.url;
          }
        }
    } else if (message?.audioMessage) {
        content = '√Åudio';
        message_type = 'audio';
        media_type = message.audioMessage.mimetype || 'audio/ogg';
        file_name = `audio_${messageTimestamp}.ogg`;
        
        // üîß CORRE√á√ÉO: Baixar e fazer re-upload do √°udio
        if (message.audioMessage.url) {
          const mediaResult = await downloadAndUploadMedia(
            message.audioMessage.url, 
            file_name, 
            media_type, 
            client!.id
          );
          if (mediaResult) {
            media_url = mediaResult.publicUrl;
            file_size = mediaResult.fileSize;
          } else {
            // Fallback para URL original se o download falhar
            media_url = message.audioMessage.url;
          }
        }
    } else if (message?.documentMessage) {
        content = message.documentMessage.caption || message.documentMessage.fileName || 'Documento';
        message_type = 'document';
        media_type = message.documentMessage.mimetype;
        file_name = message.documentMessage.fileName || `document_${messageTimestamp}`;
        
        // üîß CORRE√á√ÉO: Baixar e fazer re-upload do documento
        if (message.documentMessage.url) {
          const mediaResult = await downloadAndUploadMedia(
            message.documentMessage.url, 
            file_name, 
            media_type, 
            client!.id
          );
          if (mediaResult) {
            media_url = mediaResult.publicUrl;
            file_size = mediaResult.fileSize;
          } else {
            // Fallback para URL original se o download falhar
            media_url = message.documentMessage.url;
          }
        }
    }

    const messageToInsert = {
      conversation_id: conversation.id,
      content: content,
      message_type: message_type,
      sender: fromMe ? 'user' : 'client',
      media_url: media_url,
      media_type: media_type,
      file_name: file_name,
      file_size: file_size,
      sent_at: new Date(messageTimestamp * 1000).toISOString(),
      user_id: assignedUserId,
      from_me: fromMe,
      message_id: key.id || `msg_${Date.now()}`,
      remote_jid: remoteJid,
      instance_name: instance,
      push_name: pushName,
      raw_data: data,
      read_at: fromMe ? new Date().toISOString() : null
    };

    console.log(`üî• [${requestId}] üíæ Inserindo mensagem no banco...`);
    console.log(`üî• [${requestId}] Dados da mensagem:`, messageToInsert);
    
    const { error: msgError } = await supabase
      .from('messages')
      .insert(messageToInsert);

    if (msgError) {
      console.error(`üî• [${requestId}] ‚ùå Erro ao inserir a mensagem no banco:`, msgError);
      throw msgError;
    }
    
    console.log(`üî• [${requestId}] ‚úÖ Mensagem inserida com sucesso!`);
    console.log(`üî• [${requestId}] --- ‚úÖ Webhook finalizado com sucesso ---`);
    console.log(`üî• [${requestId}] Tempo total: ${Date.now() - startTime}ms`);

    return new Response("ok", { headers: corsHeaders });

  } catch (error) {
    console.error(`üî• [${requestId}] üî• Erro fatal no processamento do webhook:`, error);
    console.error(`üî• [${requestId}] Stack trace:`, error.stack);
    return new Response(
      JSON.stringify({ 
        error: 'Erro interno do servidor', 
        details: error.message,
        requestId: requestId
      }), 
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});